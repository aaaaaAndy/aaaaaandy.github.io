---
title: http各版本之间差异
---

HTTP 协议从开始立项到现在一共经历了 `5` 个版本:

`HTTP 0.9` -> `HTTP 1.0` -> `HTTP 1.1` -> `HTTP 2` -> `HTTP 3`

## 一、`HTTP0.9`版本

`HTTP 0.9` 是一个最古老的版本，于1990年问世，那时的`HTTP`并没有作为真正的标准被建立，而是一个简单的协议，还存在设计缺陷。

- 只支持`GET`请求方式：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息；
- 没有头部信息概念：既没有请求头也没有响应头；
- 只返回`HTTP`格式的字符串，不返回其他格式；
- 服务端相响应之后，立即关闭TCP连接。

## 二、`HTTP1.0`版本

### 1. 请求方式

请求方式新增了`POST`，`HEAD`等方式，丰富了浏览器与服务端的交互手段。

### 2. 定义头部信息概念

增添了请求头和响应头的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)

扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输

### 3. 支持任何格式

此版本中新增了**Content-Type**头部字段，用来定义各种格式，任何的资源都可以被传输，传输的格式也是多种多样的，客户端在收到响应体的内容的时候就是根据这个 `Content-Type` 去进行解析的。所以服务端返回时候必须带着这个字段。

### 4. 无状态

HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。如果需要用到状态存储可以使用Session或者Cookie。

### 5. 无连接

无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

无连接导致的性能缺陷有两种：

- _无法复用连接_，每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低
- _队头阻塞_，HTTP 1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的

## 三、`HTTP1.1`版本

### 1. 长连接

新增`Connection`字段，可以设置`keep-alive`值保持连接不断开。`HTTP 1.1`默认开启：`Connection: keep-alive`，即`TCP`连接默认不关闭可以被多个请求复用。

客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送`Connection: close`

### 2. 管道化

基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回。

### 3. 缓存处理

在HTTP1.0中主要使用header里的`If-Modified-Since`,`Expires`来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如`Cache-Control`， `Entity tag`，`If-Unmodified-Since`, `If-Match`, `If-None-Match`等更多可供选择的缓存头来控制缓存策略。

### 4. 断点续传

`range`字段与`content-range`字段

详细请看：[浏览器如何实现断点续传？](/network/range-upload.html#一、-概述)

## 四、`HTTP2.0`版本

### 1. 二进制分帧

HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。

二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。

### 2. 多路复用

在共享TCP链接的基础上同时发送请求和响应。在共享TCP链接的基础上同时发送请求和响应，基于二进制分帧，在同一域名下所有访问都是从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来。

### 3. 头部压缩

[HTTP/2 头部压缩技术介绍](https://imququ.com/post/header-compression-in-http2.html)

由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。

HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

### 4. 服务器推送

服务器可以额外的向客户端推送资源，而无需客户端明确的请求。

常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

## 五、`HTTP3.0`版本

谷歌开发的`QUIC`协议，利用`UDP`实现可靠数据传输。
