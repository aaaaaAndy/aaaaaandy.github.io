🏷: #相等 

ES2015 中有四种相等算法：

- ***抽象（非严格）相等比较*** (`==`)
- ***严格相等比较*** (`===`): 用于 `Array.prototype.indexOf`, `Array.prototype.lastIndexOf`, 和 `case`matching
- ***同值零***：用于 `%TypedArray%` 和 `ArrayBuffer` 构造函数、以及`Map`和`Set`操作，并将用于 ES2016/ES7 中的`String.prototype.includes`
- ***同值***：用于所有其他地方

JavaScript 提供三种不同的值比较操作：

- 严格相等比较 (也被称作"strict equality", "identity", "triple equals")，使用 [=== (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#identity) ,
- 抽象相等比较 ("loose equality"，"double equals") ，使用 [== (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#equality)
- 以及 `[Object.is](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is)` （ECMAScript 2015/ ES6 新特性）

## 一、非严格相等比较

非严格相等使用两个等号，也就是我们熟悉的双等，非严格相等表示**语义相等**，不要求类型一样，非严格相等在比较前会先将比较参数类型转换为一致，再进行比较，代码示例如下：

```jsx
1== 1;// true
1== '1';// true 类型不同，不影响比较结果
```

非严格相等的的转换逻辑，可以总结为如下几条规则：

- 和 `Number` 比较时，另一个值会自动转换为 `Number`
- 和 `Boolean` 比较时，另一个值会转换为 `Number`
- 简单类型与引用类型比较，对象转化成其原始类型的值，再比较
- 两个都为引用类型，则比较它们是否指向同一个对象
- `undefined` 只和 `null` 相等
- 存在 `NaN` 则返回 `false`
- `+0` 等于 `-0`

非严格相等有非常复杂的转换规则，非常难以记忆，社区中[有人](https://dorey.github.io/JavaScript-Equality-Table/)将上面的规则总结成了图片，一图胜千言，如下图所示：

![591.png](https://raw.githubusercontent.com/aaaaaAndy/picture/main/images/20230406101359.png)

```jsx
var num = 0;
var obj = new String("0");
var str = "0";
var b = false;

console.log(num == num); // true
console.log(obj == obj); // true
console.log(str == str); // true

console.log(num == obj); // true
console.log(num == str); // true
console.log(obj == str); // true
console.log(null == undefined); // true

// both false, except in rare cases
console.log(obj == null);
console.log(obj == undefined);
```

非严格相等并非带来了很多便利，通过隐式的自动转换，简化了部分场景的工作，比如 Number 和 String 的自动转换，简化了前端从表单，url 参数中获取值的比较问题，但自动转换带来的问题比便利还多。

## 二、严格相等比较

严格相等是另一种比较算法，其和非严格想等的区别是不会进行类型转换，类型不一致时直接返回 false，严格相等对应`===`操作符，因为使用三个等号，也被称作三等或者全等，严格相等示例如下：

```jsx
let result1 = ("55" === 55); // false，不相等，因为数据类型不同
let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同
```

`undefined` 和 `null` 与自身严格相等

```jsx
let result1 = (null === null)  // true
let result2 = (undefined === undefined)  // true
let result3 = (null === undefined) // false 类型不同
```

不同类型值判断规则如下，和前面的非严格相等对比，严格相等更符合直觉。

![592.png](https://raw.githubusercontent.com/aaaaaAndy/picture/main/images/20230406101446.png)

严格相等解决了非严格相等中隐式转换带来的问题，但也丢失了隐式转换带来的便利，对于类型可能不一致的情况下，比如从表单中获取的值都是字符串，保险的做法是，在比较前手动类型转换，代码示例如下：

```jsx
1 === Number('1'); // true 手动类型转换，类型防御
```

严格相等几乎总是正确的，但也有例外情况，比如 NaN 和正负 0 的问题。

在严格相等中，NaN 是不等于自己的，NaN 是(x !== x) 成立的唯一情况，在某些场景下其实是希望能够判断 NaN 的，可以使用 isNaN 进行判断，ECMAScript 2015 引入了新的 Number.isNaN，和 isNaN 的区别是不会对传入的参数做类型转换，建议使用语义更清晰的 Number.isNaN，但是要注意兼容性问题，判断 NaN 代码示例如下：

```jsx
NaN === NaN; // false

isNaN(NaN); // true
Number.isNaN(NaN); // true

isNaN('aaa'); // true 自动转换类型 'aaa'转换为Number为NaN
Number.isNaN('aaa'); // false 不进行转换，类型不为Number，直接返回false
```

严格相等另一个例外情况是，无法区分+0 和-0，代码示例如下，在一些数学计算场景中是要区分语义的。

```jsx
**+**0 **===** **-**0; *// true*
```

JavaScript 中很多系统函数都使用严格相等，比如数组的 indexOf，lastIndexOf 和 switch-case 等，需要注意，这些对于 NaN 无法返回正确结果，代码示例如下：

```jsx
[NaN].indexOf(NaN); // -1 数组中其实存在NaN
[NaN].lastIndexOf(NaN); // -1
```

## 三、同值零

同值零是另一种相等算法，名字来源于规范的直译，规范中叫做 SameValueZero，同值零和严格相等功能一样，除了处理 NaN 的方式，同值零认为 NaN 和 NaN 相等，这在判断 NaN 是否在集合中的语义下是非常合理的。

ECMAScript 2016 引入的 includes 使用此算法，此外 Map 的键去重和 Set 的值去重，使用此算法，代码示例如下：

```jsx
[NaN].incdudes(NaN); // true 注意和indexOf的区别，incdudes的语义更合理

new Set([NaN, NaN]); // [NaN] set中只会有个一个NaN，如果 NaN !== NaN的话，应该是[NaN, NaN]

new Map([
  [NaN, 1],
  [NaN, 2],
]); // {NaN => 2} 如果 NaN !== NaN的话，应该是 {NaN => 1, NaN => 2}
```

## 四、同值

同值是最后一种相等算法，其和同值零类似，但认为 +0 不等于 -0，ECMAScript 2015 带来的 [Object.is](http://object.is/) 使用同值算法，代码示例如下：

```jsx
Object.is(NaN, NaN); // true
Object.is(+0, -0); // false 📢 注意这里
```

对于数组判断是否存在的场景，如果想区分+0 和-0，可以使用 ECMAScript 2015 引入的 find 方法，自行控制判断逻辑，代码示例如下：

```jsx
[0].includes(-0);// 不能区分-0
[0].find((val)=> Object.is(val,-0));// 能区分+0和-0
```

## 五、区别

下面对比下四种算法的区别，区别如下表所示：

|  | 隐式转换 | NaN 和 NaN | +0 和 -0 |
| --- | --- | --- | --- |
| 非严格相等(==) | 是 | false | true |
| 严格相等(===) | 否 | false | true |
| 同值零(includes 等) | 否 | true | true |
| 同值(Object.is) | 否 | true | false |

## 参考文档

[JavaScript 中的相等性判断 - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness)

[如何在JavaScript中判断两个值相等](https://yanhaijing.com/javascript/2022/07/10/js-equal/)