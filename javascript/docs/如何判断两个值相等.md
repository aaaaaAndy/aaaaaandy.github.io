---
title: 如何判断两个值相等
---

## 一、基础类型相等比较

`JavaScript`提供三种不同值的比较操作：

### 1. 非严格相等`==`

相等操作符比较两个值是否相等，在比较前将两个被比较的值转换为相同类型。在转换后（等式的一边或两边都可能被转换），最终的比较方式等同于全等操作符 `===` 的比较方式。 相等操作符满足交换律。

```javascript
console.log([10] == 10); //true
console.log('10' == 10); //true
console.log([] == 0); //true
console.log(true == 1); //true
console.log([] == false); //true
console.log(![] == false); //true
console.log('' == 0); //true
console.log('' == false); //true
console.log(null == false); //false
console.log(!null == true); //true
console.log(null == undefined); //true

console.log(012 == 12); // false
console.log(012 == 10); // true
console.log(099 == 99); // true 这种情况是因为八进制中不可能出现9，所以看成一个十进制
console.log(09 == 9); // true 同上
```

它的比较规则如下：


> -   如果 Type(x)和 Type(y)相同，返回 x===y 的结果
> -   如果 Type(x)和 Type(y)不同
    -   如果 x 是 null，y 是 undefined，返回 true
    -   如果 x 是 undefined，y 是 null，返回 true
    -   如果 Type(x)是 Number，Type(y)是 String，返回 x==ToNumber(y) 的结果
    -   如果 Type(x)是 String，Type(y)是 Number，返回 ToNumber(x)==y 的结果
    -   如果 Type(x)是 Boolean，返回 ToNumber(x)==y 的结果
    -   如果 Type(y)是 Boolean，返回 x==ToNumber(y) 的结果
    -   如果 Type(x)是 String 或 Number 或 Symbol 中的一种并且 Type(y)是 Object，返回 x==ToPrimitive(y) 的结果
    -   如果 Type(x)是 Object 并且 Type(y)是 String 或 Number 或 Symbol 中的一种，返回 ToPrimitive(x)==y 的结果
    -   其他返回 false

### 2. 严格相等`===`

全等操作符比较两个值是否相等，两个被比较的值在比较前都不进行隐式转换。如果两个被比较的值具有不同的类型，这两个值是不全等的。否则，如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值全等。最后，如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是全等的。

```javascript
+0 === -0; // true
NaN === NaN; // false
```

它的比较规则如下：

> -   如果 Type(x)和 Type(y)不同，返回 false
> -   如果 Type(x)和 Type(y)相同
    -   如果 Type(x)是 Undefined，返回 true
    -   如果 Type(x)是 Null，返回 true
    -   如果 Type(x)是 String，当且仅当 x,y 字符序列完全相同（长度相同，每个位置上的字符也相同）时返回 true，否则返回 false
    -   如果 Type(x)是 Boolean，如果 x,y 都是 true 或 x,y 都是 false 返回 true，否则返回 false
    -   如果 Type(x)是 Symbol，如果 x,y 是相同的 Symbol 值，返回 true,否则返回 false
    -   如果 Type(x)是 Number 类型
        -   如果 x 是 NaN，返回 false
        -   如果 y 是 NaN，返回 false
        -   如果 x 的数字值和 y 相等，返回 true
        -   如果 x 是+0，y 是-0，返回 true
        -   如果 x 是-0，y 是+0，返回 true
        -   其他返回 false

### 3. `Object.is()`

`Object`在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0 和-0，NaN 和 NaN。

```javascript
Object.is(0, -0); // false
Object.is(+0, -0); // false
Object.is(0, +0); // true
Object.is(-0, -0); // true
Object.is(NaN, 0 / 0); // true
Object.is(NaN, NaN); // true
```

## 二、引用数据类型相等比较

### 1. `JSON.stringify(obj)`

```javascript
JSON.stringify(obj) === JSON.stringify(otherObj);
```

这种方法简单，一行代码就搞定，但是有缺点，如下：

-   当对象里`key`值顺序不一样时，就会出错
-   一些特殊类型的值，比如`undefined`，`Date`，`RegExp`等会丢失或者变形

### 2. 递归

实现思路如下：

1. 先判断两个对象的`key`值的长度。若长度不相等，则 `return false`
2. 遍历对象`obj1`，检查对象`obj2`中是否有对应的`key`值， 没有，则`return false`
3. 比较两个对象中这个`key`对应的值的类型是否相等，不相等，则`return false`
4. 如果值的类型是`undefined`、`number`、`string`、`boolean`的一种，直接两个值比较，不同，则`return false`
5. 如果值是`null`，那么 比较两个值是否相等。不等，则`return false`
6. 如果值是对象，调用自身
7. 如果值是数组，因为数组项可能是任意一种数据类型的，所以还是先比较长度，长度相等后再逐一比较数组的每一项。

此代码包含了如何比较两个对象相等 ，代码如下：

<iframe height="800" style="width: 100%;" scrolling="no" title="Untitled" src="https://codepen.io/aaaaaandy/embed/YzaRMpL?default-tab=html%2Cresult&editable=true" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/aaaaaandy/pen/YzaRMpL">
  Untitled</a> by aaaaaAndy (<a href="https://codepen.io/aaaaaandy">@aaaaaandy</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

```javascript
const NUMBER_TAG = '[object Number]';
const STRING_TAG = '[object String]';
const BOOLEAN_TAG = '[object Boolean]';
const NULL_TAG = '[object Null]';
const UNDEFINED_TAG = '[object Undefined]';
const OBJECT_TAG = '[object Object]';
const ARRAY_TAG = '[object Array]';
const ERROR_TAG = '[object Error]';
const DATE_TAG = '[object Date]';
const REGEXP_TAG = '[object RegExp]';
const MAP_TAG = '[object Map]';
const SET_TAG = '[object Set]';

// 以下两种类型一般不比较相等性
const SYMBOL_TAG = '[object Symbol]';
const FUNCTION_TAG = '[object Function]';

const toString = Object.prototype.toString;
const getKeys = Object.keys;

// map转数组
function mapToArray(map) {
	let idx = -1;
	const result = new Array(map.size);

	map.forEach(function (value, key) {
		result[++idx] = [key, value];
	});

	return result;
}

// set转数组
function setToArray(set) {
	let idx = -1;
	const result = new Array(set.size);

	set.forEach(function (value) {
		result[++idx] = value;
	});

	return result;
}

/**
 * 比较两个变量是否相等，包括引用类型
 * @param  {[type]} value  [description]
 * @param  {[type]} other  [description]
 * @param  {[type]} vStack [description]
 * @param  {[type]} oStack [description]
 * @return {[type]}        [description]
 */
function eq(value, other, vStack, oStack) {
	const valueType = toString.call(value);
	const otherType = toString.call(other);

	// 类型不同直接返回false
	if (valueType !== otherType) {
		return false;
	}

	// 这里直接进行一个简单粗暴的判断, 这里默认+0与-0相等，不再进行处理
	// 同样适用于基本类型和引用类型，如果是同一个引用也可返回true
	if (value === other) {
		return true;
	}

	// 处理NaN不相等情况
	if (value !== value && other !== other) {
		return true;
	}

	// 处理其他情况
	switch (valueType) {
		case NUMBER_TAG:
		case DATE_TAG:
		case BOOLEAN_TAG:
			return +value === +other;
		case STRING_TAG:
		case REGEXP_TAG:
		case NULL_TAG:
		case UNDEFINED_TAG:
			return '' + value === '' + other;
		case ERROR_TAG:
			return value.name === other.name && value.message === other.message;
		case MAP_TAG:
			const valueMapArr = mapToArray(value);
			const otherMapArr = mapToArray(other);

			if (!eq(valueMapArr, otherMapArr, vStack, oStack)) {
				return false;
			}
			break;
		case SET_TAG:
			const valueSetArr = setToArray(value);
			const otherSetArr = setToArray(other);

			if (!eq(valueSetArr, otherSetArr, vStack, oStack)) {
				return false;
			}
			break;
		case ARRAY_TAG:
		case OBJECT_TAG:
			// 首先对比是否为循环引用
			vStack = vStack || [];
			oStack = oStack || [];
			let vStackLength = vStack.length;

			while (vStackLength--) {
				if (
					vStack[vStackLength] === value &&
					oStack[vStackLength] === other
				) {
					return true;
				}
			}

			vStack.push(value);
			oStack.push(other);

			// 数组对比
			if (valueType === ARRAY_TAG) {
				let vLength = value.length;
				let oLength = other.length;

				if (vLength !== oLength) {
					return false;
				}

				while (vLength--) {
					if (!eq(value[vLength], other[vLength], vStack, oStack)) {
						return false;
					}
				}
			}

			// 对象对比
			if (valueType === OBJECT_TAG) {
				const vKeys = getKeys(value);
				const oKeys = getKeys(other);
				let vKeysLength = vKeys.length;

				if (vKeys.length !== oKeys.length) {
					return false;
				}

				while (vKeysLength--) {
					// 对象的key顺序可能不一样，但是对象仍然可能相等
					if (!oKeys.includes(vKeys[vKeysLength])) {
						return false;
					}

					let currentKey = vKeys[vKeysLength];
					if (
						!eq(
							value[currentKey],
							other[currentKey],
							vStack,
							oStack
						)
					) {
						return false;
					}
				}
			}
			break;
		default:
			return String(value) === String(other);
	}

	return true;
}
```
