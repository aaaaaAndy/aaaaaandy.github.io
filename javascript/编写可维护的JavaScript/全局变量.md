🏷: #编写可维护的JavaScript  #变量
JavaScript执行环境在很多方面都有其独特之处。全局变量和函数的使用便是其中之一。事实上，JavaScript的初始执行环境是由多种多样的全局变量所定义的，这些全局变量在脚本环境创建之初就已经存在了。这些都是挂载在全局对象上的。

在浏览器中，window对象往往重载并等同于全局对象，因此任何在全局作用域中声明的变量和函数都是window对象的属性，如下所示，两者都是window对象的属性。

```javascript
var color = 'red';
 
function showColor () {
    alert(color);
}

console.log(window.color);    // 'red'
console.log(typeof window.showColor);    // 'function'
```

## 一、全局变量带来的问题

一般来讲，创建全局变量被认为是糟糕的事，尤其是在团队开发的大背景下更是如此。

命名冲突： 当脚本中的全局变量和全局函数越来越多时，发生命名冲突的概率也大为增加。如上代码所示，当全局变量color和全局函数showColor()在同一个文件时还好，但是当有很多地方引用全局变量和全局对象时，追踪起来就变得相当麻烦。

代码脆弱： 一个依赖于全局变量的函数即是深耦合于上下文环境之中，如果环境发生改变，函数很可能就失效了。

意外的全局变量： 当你给一个未被var语句声明过的变量赋值时，JavaScript就会自动创建一个全局变量，尤其当你无意中创建的全局变量与系统定义的全局变量相同时，会修改系统的全局变量的值。如下：

```javascript
function doSomething () {
    var count = 10;
        title = "Maintainable JavaScript";    //  不好的写法，创建了全局变量
}
```

## 二、解决全局变量带来的问题

### 1. 避免意外的全局变量

避免意外的全局变量可以使用JSLint和JSHint等检测工具来，或者使用JS的严格模式，使用JS的严格模式会通知JavaScript引擎在运行代码前执行更严格的错误处理和语法检查。其中一个规则可以探测未声明变量的赋值操作。

### 2. 单全局变量

单全局变量的含义即只创建一个全局变量。如JQuery定义了两个特定的全局变量，$和jQuery，只有在$被其他类库使用了的情况下，为了避免冲突，应当使用jQuery。

“单全局变量” 的意思是所创建的这个唯一全局对象名是独一无二的，并将你所有的功能代码都挂载到这个全局对象上。因此每个可能的全局变量都成为你唯一全局对象的属性，从而不会创建多个全局变量。

### 3. 命名空间

即使你的代码只有一个全局对象，也存在着全局污染的可能性。大多数使用单全局变量模式的项目同样包含“命名空间”的概念。命名空间是简单的通过全局对象的单一属性表示的功能分组。将功能按照命名空间进行分组，可以让你的全局对象变得井然有序，同时让团队成员能够知晓新功能应该属于哪个部分。

现有js中并不支持原生的命名空间。在JS中创建的任何对象都默认是全局对象。在现代的大规模JS开发中，不采用命名空间会造成非常糟糕的命名方式，导致代码丑陋不可读。当引入第三方库后，更可能会发生明明覆盖的情况。

好消失是：在ES6中，就有了native的命名空间可以用了，但是当下我们还需要一些特殊的手段来模拟命名空间的概念。简单来说，就是创建一个简单字面量来打包所有的相关函数和变量。这个简单的对象字面量模拟了命名空间的作用。

```javascript
var NAMESPACE = {
    person: funnction(name) {
        this.name = name;
        this.getName = function() {
            return this.name;
        }
    }
}

// 调用方法
var p = new NAMESPACE.person("andy");
p.getName()
```

如此一来，我们就可以通过命名空间来声明多个person对象了。但是这里还有一个问题，我们这里使用的是一个全局对象，在添加这个“命名空间”的时候，我们有可能覆盖全局空间中的同名对象。因此我们需要再声明命名空间之前进行检查，保证全局空间的安全：

```javascript
// 在声明之前进行检查，防止覆盖全局的同名对象。
var NAMESPACE = NAMESPACE || {};
```

若全局空间中已经有同名对象，则不覆盖该对象；否则创建一个新的命名空间。采用了这个安全地命名空间后，声明的方法也需要略作改动：

```javascript
var NAMESPACE = NAMESPACE || {};

MYNAMESPACE.person = function(name) {
    this.name = name;
};

MYNAMESPACE.person.prototype.getName = function() {
    return this.name;
};

// 使用方法
var p = new MYNAMESPACE.person("ifcode");
p.getName();        // ifcode
```

注意在定义命名空间构造函数时，需要将其定义在prototype上，否则新建的实例无法访问对象的方法。

### 4. 模块化

另外一种基于单全局变量的扩充方法是模块，模块是一种通用的功能片段，它并没有创建新的全局变量或命名空间。相反，这些代码都存放于一个表示执行一个任务或发布一个借口的单函数中。可以用一个名称来表示这个模块，同样这个模块可以依赖其他模块。

### 5. 零全局变量

这个种方法应用场景不多，只有在特殊场景下才会应用。最常见的情形是一段不会被其他脚本访问到的完全独立的脚本，之所以存在这种情形，是因为所有所需的脚本都会合并到一个文件，或者因为这段非常短小且不提供任何借口的代码会被插入至一个页面中，最常见的用法是创建一个书签。

书签是独立的，他们并不知道页面中包含什么且不需要页面知道它的存在。最终我们需要一段“零全局变量”的脚本嵌入到页面中，实现方法就是使用一个立即执行的函数调用并将所有脚本放置其中，比如“

```javascript
(function (win)) {
    var doc = win.document;
    
    // 在这里定义其他的变量

    // 其他相关代码
}
```

这段代码注入到页面中不会产生任何的全局变量，之后你可以通过将函数设置为严格模式来避免创建全局变量。

<!-- more -->
